<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="sewStyle.css">
    <title>Introduction Software engineering</title>
    
</head>
<body>
    <div class="content" id="swp">
        <h2>Software Engineeering paradigms:</h2>
        <p><b>SDLC:</b> SDLC is a step by step procedure or systematic approach to develop software and it is followed within a
            software organization. It consists of various phases which describe how to design, develop, enhance and maintain
            particular software</p>
        <p>A software development lifecycle (SDLC) model conceptually presents SDLC in an organized fashion to help organizations implement it. Different models arrange the SDLC phases in varying chronological order to optimize the development cycle</p>
        <img src="C:\Users\LENOVO\Documents\SEwebpage\SDLC_BWC.png" width="400px" height="400px">
        <p>Diferent SDLC models are:</p>
        <ul class="list">
            <li><a href="sq.html">Sequential</a></li>
            <li><a href="in.html">Incremental</a></li>
            <li><a href="ev.html">Evolutionaty</a></li>
            <li><a href="sp.html">Specialized Process Models</a></li>
        </ul>
    </br>
   </div>
   <div class="content" id="sq">
       <p><b>Sequential Model:</b> It is also called a <b>linear sequential model</b>, <b>classic life cycle</b> or <b>waterfall model</b>. It suggests a systematic, sequential approach to Software Development that begins at a systematic level and progresses through communication, planning, modeling, construction, and deployment. The steps are as follows:</p>
       <img src="C:\Users\LENOVO\Documents\SEwebpage\jira-waterfall-model.png">
       <p><b>Some Circumstances where the use of the Waterfall model is most suited are:</b></p>
         <ul class="list">
             <li>When the requirements are constant and not changed regularly.</li>
<li>A project is short</li>
<li>The situation is calm</li>
<li>Where the tools and technology used is consistent and is not changing</li>
<li>When resources are well prepared and are available to use.</li>
</ul>
       <p><b>Advantages of Sequential model:</b></p>
       <ul class="list">
        <li>This model is simple to implement also the number of resources that are required for it is minimal.</li>
        <li>The requirements are simple and explicitly declared; they remain unchanged during the entire project development.</li>
        <li>The start and end points for each phase is fixed, which makes it easy to cover progress.</li>
        <li>The release date for the complete product, as well as its final cost, can be determined before development.</li>
        <li>It gives easy to control and clarity for the customer due to a strict reporting system</li>
       </ul>

       <p><b>Disadvantages of Sequential model:</b></p>
       <ul class="list">
        <li>The risk factor is higher, so this model is not suitable for more significant and complex projects.</li>
        <li>This model cannot accept the changes in requirements during development.</li>
        <li>The start and end points for each phase is fixed, which makes it easy to cover progress.</li>
        <li>It becomes tough to go back to the phase. For example, if the application has now shifted to the coding phase, and there is a change in requirement, It becomes tough to go back and change it.</li>
       </ul>
       </div>

<div class="content" id="in">
        
    <p><b>Incremental model:</b>Incremental Model is a process of software development where requirements divided into multiple standalone modules of the software development cycle. In this model, each module goes through the requirements, design, implementation and testing phases. Every subsequent release of the module adds function to the previous release. The process continues until the complete system achieved.</p>
    <img src="C:\Users\LENOVO\Documents\SEwebpage\Incremental-Model.png">
    <p><b>The various phases of incremental model are:</b></p>
     <ol class="list">
        <li><b>Requirement analysis:</b> In the first phase of the incremental model, the product analysis expertise identifies the requirements. And the system functional requirements are understood by the requirement analysis team. To develop the software under the incremental model, this phase performs a crucial role.</li>
        <li><b>Design & Development:</b>In this phase of the Incremental model of SDLC, the design of the system functionality and the development method are finished with success. When software develops new practicality, the incremental model uses style and development phase.</li> 
        <li><b>Testing:</b>In the incremental model, the testing phase checks the performance of each existing function as well as additional functionality. In the testing phase, the various methods are used to test the behavior of each task.</li>
        <li><b>Implementation:</b>Implementation phase enables the coding phase of the development system. It involves the final coding that design in the designing and development phase and tests the functionality in the testing phase. After completion of this phase, the number of the product working is enhanced and upgraded up to the final system product</li>
    </ol>
    <p><b>When is Incremental Model used</b></p>
    <ul class="list">
        <li>When the requirements are superior.</li>
        <li>A project has a lengthy development schedule.</li>
        <li>When Software team are not very well skilled or trained.</li>
        <li>When the customer demands a quick release of the product.</li>
        <li>You can develop prioritized requirements first</li>
    </ul>
    <p><b>Advantage of Incremental Model</b></p>
      <ol class="list">
        <li>Errors are easy to be recognized.</li>
        <li>Easier to test and debug.</li>
        <li>More flexible.</li>
        <li>Simple to manage risk because it handled during its iteration.</li>
        <li>The Client gets important functionality early.</li>

      </ol> 

      <p><b>Disadvantage of Incremental Model</b></p>
      <ol class="list">
        <li>Need for good planning.</li>
        <li>Total Cost is high.</li>
        <li>Well defined module interfaces are needed</li>
        </ol>
 </div>

<div class="content" id="ev">
    <p><b>Evolutionary Model: </b>Evolutionary model is also referred to as the successive versions model and sometimes as the incremental model. In Evolutionary model, the software requirement is first broken down into several modules (or functional units) that can be incrementally constructed and delivered</p>
    <p>The evolutionary model is shown in Figure 6. Each successive version/model of the product is a fully functioning software capable of performing more work than the previous versions/model. The evolutionary model is normally useful for very large products, where it is easier to find modules for incremental implementation.</p>

    <img src="C:\Users\LENOVO\Documents\SEwebpage\Evolutionary-Model-of-Software-Development.webp">
    <p>Often, evolutionary model is used when the customer prefers to receive the product in increments so that he can start using the different features as and when they are developed rather than waiting all the time for the full product to be developed and delivered</p>
    <p><b>Advantages of Evolutionary Model</b></p>
    <ul class="list">
        
        <li>Large project: Evolutionary model is normally useful for very large products.</li>
        
       <li>User gets a chance to experiment with a partially developed software much before the complete version of the system is released.</li>
        
        <li>Evolutionary model helps to accurately elicit user requirements during the delivery of different versions of the software.</li>
        
        <li>The core modules get tested thoroughly, thereby reducing the chances of errors in the core modules of the final products.</li>
        
        <li>Evolutionary model avoids the need to commit large resources in one go for development of the system.</li>
        </ul>

    <p><b>Disadvantages of Evolutionary Model</b></br>
        Difficult to divide the problem into several versions that would be acceptable to the customer and which can be incrementally implemented and delivered</p>
</div>
<div class="content" id="sp">
    <p><b>Specialized Process Model: </b>Special process models take on many of the characteristics of one or more of the conventional models. However, specialized models tend to be applied when a narrowly defined software engineering approach is chosen.</p>
    <p>here are 3 types of specialized process models:</p>
    <ol class="list">
        <li>Component Based Development </li>
        <li>Formal Methods Model</li>
      <li>Aspect Oriented Software development </li>
    </ol>
    
<p><b>Component Based Development :</b>  Commercial off-the-shelf (COTS) software components, developed by vendors who offer them as products, provide targeted functionality with well-defined interfaces that enable the component to be integrated into the software that is to be built. The component-based development model incorporates many of the characteristics of the spiral model. It is evolutionary in nature, demanding an iterative approach to the creation of software. However, the component-based development model constructs applications from prepackaged software component. Modeling and construction activities begin with the identification of candidate components. These components can be designed as either conventional software modules or object-oriented classes or packages  of classes. Regardless of the technology that is used to create the components, the component-based development model incorporates the following steps: 
</br> 1. Available component-based products are researched and evaluated for the application domain in question.<br> 2. Component integration issues are considered.</br> 3. A software architecture is designed to accommodate the components./br> 4. Components are integrated into the architecture.</br> 5. Comprehensive testing is conducted to ensure proper functionality</p>
<p><b>Formal Methods Model :</b> The formal methods model encompasses a set of activities that leads to formal mathematical specification of computer software. Formal methods enable to specify, develop, and verify a computer-based system by applying a rigorous, mathematical notation. A variation on this approach, called cleanroom software engineering is currently applied by some software development organizations.</p>
<p>When formal methods are used during design, they serve as a basis for program verification and therefore enable you to discover and correct errors that might otherwise go undetected. The formal methods model offers the promise of defect-free software.There are some of the disadvantages too: <br> • The development of formal models is currently quite time consuming and expensive. <br> • Because few software developers have the necessary background to apply formal methods, extensive training is required. <br> • It is difficult to use the models as a communication mechanism for technically unsophisticated customers.</p>
<p><b>Aspect Oriented Software Development :</b>  Regardless of the software process that is chosen, the builders of complex software invariably implement a set of localized features, functions, and information content. These localized software characteristics are modeled as components and then constructed within the context of a system architecture. As modern computer-based systems become more sophisticated certain concerns span the entire architecture. Some concerns are high-level properties of a system, Other concerns affect functions, while others are systemic. </br>When concerns cut across multiple system functions, features, and information, they are often referred to as crosscutting concerns. Aspectual requirements define those crosscutting concerns that have an impact across the software architecture. Aspect-oriented software development (AOSD), often referred to as aspect-oriented programming (AOP), is a relatively new software engineering paradigm that provides a process and methodological approach for defining, specifying, designing, and constructing aspects.</p>



</div>

    <div id="footer">
        <a href="Sewhome.html"><button>Back to home</button></a>
    </div>
</body>
</html>